# Списки и операции с ними
## А также кортежи, срезы и генераторы

Приветствую! На прошлой паре мы не зря изучили функцию range()... Сегодня вы узнаете:
- Насколько удобны списки в Python 
- Что такое срезы, и как они помогут решать задачи
- Как написать команду для создания заполненного списка

## Списки и индексы
В Python вместо массивов используются списки. Они имеют множество применений: хранить информацию об объектах одного рода (список шахматных фигур, набор точек), создавать набор значений для цикла `for` или даже заменять этот цикл `for`. Задать список с любыми данными любых типов очень просто:
```py
a = [2, 4, 6, 8, 10]
b = ['Я', 'пишу', 'слова', 'отдельно']
с = [1]
```
Переменная `a` — это целый список. Как же теперь вывести отдельный элемент? Так же, как в жизни мы пользуемся нумерацией, когда пишем список чего-то, в Python у каждого элемента списка есть номер, который называется **индексом**, только нумерация начинается с нуля. То есть в списке из 5 элементов первый будет с индексом 0, а последний — 4:
```py
print(a[0])
>>> 2
print(a[4])
>>> 10
```
Отрицательные индексы, начиная с `-1`, позволяют вывести n-ный элемент с конца:
```py
print(a[-2])
>>> 8
```
Ещё список всегда хранит свою длину, которую можно получить функцией `len()`:
```py
print(len(a))
>>> 5
```

### Использование в циклах
Есть два разных способа вывести все элементы списка:
```py
a = [2, 4, 6]

for i in range(len(a)):
  print(i, a[i])
>>> 0 2
>>> 1 4
>>> 2 6
  
for name in a:
  print(name)
>>> 2
>>> 4
>>> 6
```
Уже теперь мы можем решить одну из тестовых задач:
```
Ученики пишут тест, правильные ответы на который находятся в массиве ["a", "a", "b", "d"].  
В таких же массивах находятся ответы учеников, например, вот, что получилось у одного из них:  ["с", "a", "", "d"].  
За правильный ответ ученик получает 4 балла, за неправильный — теряет 1 балл, а за пустой ответ можно получить 0 баллов.  
Дано: Ответы на тест. Ответ: число баллов ученика. Придумайте алгоритм решения этой задачи и опишите шаги вашего решения.
```
А решение будет таким:
```py
sol = ["a", "a", "b", "d"]
otv = ["с", "a", "", "d"]

s = 0
for i in range(len(sol)):
    if otv[i]:
        if otv[i] == sol[i]:
            s += 4
        else:
            s -= 1
print(s)
```
### Кортежи — неизменяемые списки
Запомните названия типов данных:  
- list — список  
- tuple — неизменяемый список
  
Кортежи не отличаются от списков ничем, кроме того, что их содержимое нельзя менять. Кортежи стоит использовать вместо списков всегда, когда мы не собираемся добавлять или убирать из него элементы при помощи кода. На практике большинство людей всё равно использует списки, но они работают медленнее, так что есть, к чему стремиться:) Кортежи можно определить так:
```
a = (1, 2, 3)
b = (1,)
```

### Двухмерные списки
В отличие от других языков программирования, где используются массивы, в Питоне мы можем наполнять списки и кортежи элементами разных типов:
```py
a = ['a', 2, ['t']]
```
Одним из элементов предыдущего списка является ещё один список. Так мы можем создать уже двухмерный список:
```py
double_list = [[1,2,3], [4,5,6], [7,8,9]]
```
Тогда к элементам можно обращаться так:
```py
print(double_list[1])
>>> [4,5,6]
print(double_list[1][0])
>>> 4
```
Давайте посмотрим на задачу из второго теста:
```
Дан массив для игры в крестики-нолики. Какое минимальное количество слов if понадобится,  
чтобы проверить выигрыш одного из игроков, если не использовать слова elif, else, switch и case?
a = [[0,0,0],
     [0,0,0],
     [0,0,0]]
```
Речь о том, чтобы написать код, который решит эту задачу с минимальным количеством условий. Это очень плохое решение с точки зрения кода, но в нём есть всего одно слово `if`:
```py
solutions = [[(0,0), (0,1), (0,2)], [(1,0), (1,1), (1,2)], [(2,0), (2,1), (2,2)],
             [(0,0), (1,0), (2,0)], [(0,1), (1,1), (2,1)], [(0,1), (1,1), (2,1)],
             [(0,0), (1,1), (2,2)], [(0,2), (1,1), (2,0)]] 
            # координаты крестиков/ноликов во всех возможных вариантах победы
for i in solutions:
    if a[i[0][0]][i[0][1]] == a[i[1][0]][i[1][1]] and a[i[1][0]][i[1][1]] == a[i[2][0]][i[2][1]]:
        print('Кто-то выиграл! Нам не важно, кто:)')
```
Решение ужасно не только потому, что вы наверняка запутались в индексах трёхмерного списка, подающихся в двухмерный список, а ещё и потому, что для шахмат решений будет не восемь, а как минимум миллион (возможно, намного больше). Но в нём один `if`:)

## Операции со списками
```py
a = ['Андрей', 'Кирилл', 'Владимир', 'Игнат']
```
Вот так просто элементы списка можно изменять:
```py
a[3] = 'Игорь'
```
Вот все способы добавить элемент в конец списка:
```py
a.append('Виктория')
a += ['Марина']
```
Первый способ мы используем по умолчанию. Второй — конкатенация — отлично подойдёт для того, чтобы добавить элемент в начало списка:
```py
a = ['Марина'] + a
print(a)
>>> ['Марина', 'Андрей', 'Кирилл', 'Владимир', 'Игорь', 'Виктория', 'Марина']
```
Точно так же есть два способа убрать элемент. Первый — метод `pop()`. **Метод** — это функция, которая относится какому-то объекту и доступна только для переменных определённого типа данных. Вот так это выглядит:
```py
name = a.pop()
print(name)
>>> 'Марина'
```
Как вы могли догадатсья, `append()` — это тоже метод. В переменную `name` при вызове функции будет записано то, что функция "возвращает". В данном случае это тот элемент, который мы удалили из списка. Если не подать в функцию аргумент, она удалит и вернёт последний элемент списка. Мы будто берём верхний лист из стопки. Если подать в качестве аргумента индекс, функция удалит его:
```py
a.pop(3)
print(a)
>>> ['Марина', 'Андрей', 'Кирилл', 'Игорь', 'Виктория']
```
Ещё один способ убрать элемент — знать его индекс и воспользоваться оператором `del`. Или достать индекс методом `index()`:
```py
ind = a.index('Кирилл')
print(ind)
>>> 2
del a[ind]
```

### Задачи ❓
1. Выведите на экран все элементы списка, кроме первого и последнего, используя функцию `len()` и цикл `for`:
```py
a = [1, 2, 3, 4, 5, 6]
```
2. Дан список с числами. Добавьте в него элементы так, чтобы он содержал все целые числа от 1 до 9 по порядку:
```py
a = [3, 4, 5, 6]
```
3. Дан список нулей и единиц. Любым способом сделайте так, чтобы количество нулей и единиц в нём было равным:
```py
a = [1, 0, 1, 1, 0, 0, 1]
```

## Срезы — способ взять часть списка или кортежа
Использование срезов невероятно похоже на использование функции `range()`. Конечно, это не случайно. Давайте сделаем ещё один список и посмотрим, как можно вывести его часть при помощи `range()`:
```py
a = ['Марина', 'Андрей', 'Кирилл', 'Владимир', 'Игорь', 'Виктория']

for i in range(3):
    print(a[i])
>>> 'Марина' 'Андрей' 'Кирилл'    # в столбик

for i in range(5, len(a)):
    print(a[i])
>>> 'Виктория'

for i in range(2,4):
    print(a[i])
>>> 'Кирилл' 'Владимир'    # в столбик
    
for i in range(0,6,2):
    print(a[i])
>>> 'Марина' 'Кирилл' 'Игорь'    # в столбик  
```
А вот то же самое, но при помощи срезов, только здесь у нас получится список, а не набор значений в столбик:
```py
print(a[:3])
>>> ['Марина', 'Андрей', 'Кирилл']

print(a[5:])
>>> ['Виктория']

print(a[2:4])
>>> ['Кирилл', 'Владимир']
    
print(a[:6:2])
>>> ['Марина', 'Кирилл', 'Игорь']
```
Или так:
```py
for n in a[:6:2]:
    print(n)
>>> 'Марина' 'Кирилл' 'Игорь'    # в столбик      
```
Написав одно число в квадратных скобках, мы получим **объект**. Написав хотя бы одно двоеточие, мы получим **срез** — просто ещё один список. Число перед двоеточием — начало среза, а после — конец. Так же, как и в `range()`, первое число входит в интервал, а второе — нет. Если перед/после двоеточия нет числа, компьютер считает, что мы написали `0` или `len(a)` соответственно. То есть запись `a[:3]` означает "От начала до 3", а запись `a[5:]` — "От 5 и до конца"  
Если двоеточия у нас два, то можно добавить третье число — шаг. Всё как в функции `range()`.

### Часто используемые срезы
Есть парочка срезов, которые заменяют некоторые функции ввиду своей уникальности. Но для начала хочется кое-что объяснить. Список — это набор объектов, каждый из которых имеет место в памяти компьютера, даже если не имеет названия как переменная. Если мы создадим копию переменной списка и изменим один элемент в одном списке, он изменится во втором:
```py
a = [1, 2, 3]
b = a
a[1] = 0
print(b)
>>> [1, 0, 3]
```
Как же этого избежать, если нам нужно сделать дубликат списка? Ответ дают срезы:
```py
a = [1, 2, 3]
b = a[:]
a[1] = 0
print(b)
>>> [1, 2, 3]
```
Ещё один срез переворачивает список. Устроен он очень просто:
```py
print(b[::-1])
>>> [3, 2, 1]
```
### Строки как массивы
Строки в Python — это тоже массивы. Именно поэтому мы на прошлой паре могли использовать их для цикла `for`. Для них работают функция длины, индексы и срезы:
```py
b = 'Георгий'
print(b[-1])
>>> 'й'
print(b[2:5])
>>> 'орг'
print(b[::-1])
>>> 'йигроеГ'
print(len(b))
>>> 7
```
Так как строка по сути является списком символов, она может быть добавлена к списку при помощи конкатенации. Но обратите внимание на то, что из этого получится:
```py
a = []
a += ['Марина']
a += 'Марина'
print(a)
>>> ['Марина', 'М', 'а', 'р', 'и', 'н', 'а']
```
Поэтому мы и используем `append()`:) Он добавляет в список всегда один элемент.

### Задачи ❓
4. В срезах можно использовать отрицательные индексы. Давайте решим эту задачу снова, но уже с помощью этой подсказки. Выведите на экран все элементы списка, кроме первого и последнего:
```py
a = [10, 11, 12, 13, 14, 15]
```
5. Определите, что будет выведено на экран. В ответ нужно записать цифры — элементы списка, можно без запятых и скобок:
```py
a = [1, 2, 3, 4]
print(a[:2])
print(a[1:])
print(a[1:3])
print(a[::2])
print(a[::-1])
```
6. Дан список с числами. Добавьте в него элементы так, чтобы он содержал все целые числа от 1 до 5 по порядку:
```py
a = [1, 2, 4, 5]
```

## Генераторы
Зачастую нам нужно заполнить список или словарь данными, обладающими закономерностью. В этом нам помогут генераторы:
```py
a = [i**2 for i in range(1, 6)]
print(a)
>>> [1, 4, 9, 16, 25]
```
Нет, ну вы видели, видели? С условиями тоже можно:
```py
a = [1,5,4,7]
b = [i+1 for i in a if i > 4]
print(b)
>>> [6,8]
```
Что фактически заменяет нам код:
```py
a = [1,5,4,7]
b = []
for i in a:
    if i > 4:
        b.append(i+1)
```
![image](https://user-images.githubusercontent.com/56085790/138415037-c1084784-159a-4e11-9bb0-f2372f5a4c1f.png)  
Сколько же места мы сэкономили!!! Причём генератор выполняет код быстрее, чем цикл `for`! С помощью генератора можно не только создать, но и вывести список:
```py
a = [1,2,3]
[print(i) for i in a]
>>> 1
>>> 2
>>> 3
```
Обратите внимание, что в этом случае списку даже не обязательно давать переменную. Просто при создании этого списка вызывается функция `print()`, которая выводит элементы списка на экран. 
А так можно создать набор чисел:
```py
a = [i for i in range(2,15,3)]
print(a)
>>> [2, 5, 8, 11, 14]
```
По такому же принципу создаются словари:
```py
b = {i: i*3 for i in range(1,4)}
print(b)
>>> {1: 3, 2: 6, 3: 9}
```

### Задачи ❓
1. С помощью генератора превратите строку `'721282'` в список `[7, 2, 1, 2, 8, 2]` и найдите самую большую цифру в числе.
