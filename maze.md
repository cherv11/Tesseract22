# Алгоритмы поиска пути
## Графы и примеры
Привет, сегодня у нас кое-что сложное и интересное, давайте сразу к делу!  
В разработке игр повсеместно используются алгоритмы поиска пути. Вашему игровому персонажу то и дело нужно найти кратчайший путь до следующей точки. Приведём простейший пример такой задачи:  

![image](https://user-images.githubusercontent.com/56085790/151000738-bf14b16f-9f36-4a51-a2f8-aeb6376f2026.png)  

Для поиска этого пути можно применить алгоритм поиска по графу. Тогда нам нужно сделать такой граф:  

![image](https://user-images.githubusercontent.com/56085790/151000976-ce6e32da-28dd-487f-a432-ce8555996f48.png)

Окей, но этот граф позволяет нам выйти из здания, но не позволит перемещаться, как мы захотим, и достать до любого уголочка карты(( В таком случае, это будет гораздо медленнее, но давайте сделаем сетку:  

![image](https://user-images.githubusercontent.com/56085790/151001558-a1fadaed-9f40-4074-a2f9-0e9896b18805.png)

Чтобы написать такой граф на питоне, нам достаточно сделать множество точек с координатами (i, j) и множество связей между двумя точками в графе, которые выглядят как (i1, j1, i2, j2). То есть для питона граф — это всего лишь два списка, в чём мы скоро убедимся!  
Всё остальное — наша фантазия! Граф накладывается на дороги, мосты и здания, делая их проходимыми, но для компьютера существует только граф. Давайте посмотрим, как это выглядит в играх. Пример простого графа, когда есть всего несколько точек:

![image](https://user-images.githubusercontent.com/56085790/151003686-330d795c-d0cd-4794-8f84-903698e4955c.png)

Примеры сложных графов, где находится кратчайшее расстояние:

![image](https://user-images.githubusercontent.com/56085790/151004816-5506f0b8-e565-4c36-be55-e7ffa01660aa.png)

Здесь мы можем двигаться по шестиугольной сетке в любом направлении, но алгоритм поиска пути показывает кратчайший путь до выбранной клетки и подсвечивает вообще все клетки, на которые моим лучникам хватит очков передвижения на этом ходу. Ещё пример: 

![image](https://user-images.githubusercontent.com/56085790/151005721-389c697b-fd83-48af-97d4-35e14b923e48.png)

Здесь тоже остановимся. Зелёная точка — место моего клика мышью. Но персонаж пошёл не напрямик, а нашёл кратчайший путь и пошёл сразу направо, чтобы обойти препятствие.

Итак, мы разобрались в графах и посмотрели несколько примеров, где алгоритм поиска пути был полезен. Давайте теперь построим граф!

## Делаем граф
А делать мы будем лабиринт, который по-английски называется *maze*. Мы будем проходить лабиринт сверху вниз, поэтому применим небольшую хитрость: стены лабиринта, по совместительству вершины нашего графа, будут генерироваться с разной вероятностью для вертикальных и горизонтальных черт. Если вероятность для горизонтальных черт будет ниже, мы почти наверняка сделаем лабиринт проходимым сверху вниз! Сейчас нарисую. Вот наше множество точек:

![image](https://user-images.githubusercontent.com/56085790/151012152-46523e95-b6ec-4a3e-83c3-83600d607384.png)

Вероятности будут разными:

![image](https://user-images.githubusercontent.com/56085790/151012674-3f6f9856-18b2-4993-b110-7d43144b57ce.png)

Что обеспечит нам проходимость лабиринта:

![image](https://user-images.githubusercontent.com/56085790/151013120-b619104a-da0a-4a7c-af91-25ff038225e8.png)

Зададим наши переменные:
```py
FULL_WINDOW = 1920, 1080
FPS = 60
MAZE_SIZE_X, MAZE_SIZE_Y = 64, 64 # Размер лабиринта
MAZE_START_CORDS = 180, 110 # Отступ от угла экрана
# Размер клетки, который подстроится под размер лабиринта так, чтобы ничего не вылезало за экран
TILE_SIZE = (FULL_WINDOW[1]-200)//MAZE_SIZE_Y 
START_POINT = MAZE_SIZE_X//2, 0 # Точка старта сверху посередине
HORIZONTAL_LINES_CHANCE = 35 # Шанс появления для горизонтальных линий
VERTICAL_LINES_CHANCE = 50 # Шанс для вертикальных линий
horizontal_lines = [] # Список горизонтальных линий
vertical_lines = [] # Список вертикальных линий
```

Ещё нам понадобится вот такая функция, которая принимает число от 0 до 100 и возвращает True с аналогичным шансом:
```py
def chance(a, b=100):
    if random.randint(1, b) <= a:
        return True
    return False
```

А вот и сама функция генерации лабиринта. Проходимся по всем точкам. У каждой из них с определённой вероятностью появится вертикальная линия, ведущая вниз, и горизонтальная, ведущая вправо:
```py
def generate_maze():
    global horizontal_lines
    global vertical_lines
    horizontal_lines = []
    vertical_lines = []
    for i in range(MAZE_SIZE_X):
        for j in range(MAZE_SIZE_Y):
            if chance(HORIZONTAL_LINES_CHANCE):
                horizontal_lines.append((i,j))
            if chance(VERTICAL_LINES_CHANCE):
                vertical_lines.append((i,j))

generate_maze()
```

Внимательные заметят, что у нас нет списка самих точек, а есть только список линий, который мы разделили на два, в котором есть только координаты одной точки, а нам нужны две. Это тоже хитрость! Если все линии в нашем графе ведут вправо и вниз, координаты второй точки мы можем вычислить в любой момент!

Если написать ещё пару строк для показа лабиринта на экране, а заодно добавить фон, мы увидим следующее:
```py
def on_draw(self):
    self.clear()
    self.sprites.append(arcade.Sprite('bck.png', center_x=WINDOW_WIDTH//2, center_y=WINDOW_HEIGHT//2))
    self.sprites.draw()
        arcade.draw_rectangle_outline(MAZE_START_CORDS[0]+TILE_SIZE*MAZE_SIZE_X//2, MAZE_START_CORDS[1]+TILE_SIZE*MAZE_SIZE_Y//2, TILE_SIZE*MAZE_SIZE_X, TILE_SIZE*MAZE_SIZE_Y, BLACK, 3)
        for i,j in vertical_lines:
            arcade.draw_line(MAZE_START_CORDS[0]+i*TILE_SIZE, MAZE_START_CORDS[1]+j*TILE_SIZE, MAZE_START_CORDS[0]+i*TILE_SIZE, MAZE_START_CORDS[1]+(j+1)*TILE_SIZE, BLACK, 3)
        for i,j in horizontal_lines:
            arcade.draw_line(MAZE_START_CORDS[0]+i*TILE_SIZE, MAZE_START_CORDS[1]+j*TILE_SIZE, MAZE_START_CORDS[0]+(i+1)*TILE_SIZE, MAZE_START_CORDS[1]+j*TILE_SIZE, BLACK, 3)
```

![image](https://user-images.githubusercontent.com/56085790/151013315-caf88bf7-0ccd-420a-a292-8f2cad0a3228.png)

Лабиринт построен. Теперь посмотрим на то, какие алгоритмы поиска пути у нас бывают!

## Разные алгоритмы для разных целей

Главный алгоритм, который мы и будем использовать — **поиск в ширину**. Он пишется так:
1. Создаём три списка и словарь. Их названия — текущие точки, исследованные точки и новые точки. Словарь назовём *пути*.
2. Надо добавить в список текущих точек нашу первую точку — точку старта. В словарь путей добавим путь до этой точки: ключ — это точка, значение — пустой список (мы можем добраться до этой точки за 0 ходов, не наступая на другие точки, поэтому путь пустой)
3. Исследуем соседние точки. Проходимся по списку текущих точек (в начале там одна точка) и находим клетки слева, справа, сверху и снизу. Если они ещё не находятся в списке исследованных (мы же не пойдём обратно?) и с этой стороны нет стены, то добавляем точку в список "новые точки", а путь к новой точке — в словарь как путь до нашей точки + одна текущая клетка.
4. После исследования всех точек добавляем список текущих точек к списку исследованных. Список *новые точки* теперь становится списком *текущие точки*
5. Повторяем шаги 3-4, пока не найдём нужную нам точку.

Можно посмотреть на реализацию этого алгоритма на [видео](https://www.youtube.com/watch?v=YM6Swr6kcBw)!

Ещё один алгоритм, заслуживающий нашего внимания — алгоритм Дейсктры. Он позволяет учитывать, что не все узлы графа имеют одинаковую длину. Перевожу на русский: в игре может быть так, что идти по полю быстрее, чем по холмам, снегу или грязи, а значит, это нужно учесть! Наглядно смотрим это на [видео](https://www.youtube.com/watch?v=6WzhjIohHPg)))

A* — это модификация алгоритма Дейкстры, оптимизированная для единственной конечной точки. Алгоритм Дейкстры может находить пути ко всем точкам, A* находит путь к одной точке. Он отдаёт приоритет путям, которые ведут ближе к цели. [Видео](https://www.youtube.com/watch?v=g024lzsknDo) также прилагается.

